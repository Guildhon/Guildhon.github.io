My Note
-------- 
> Linux常用命令

ctrl+L清屏

### 查看文件：ls
- -a 显示所有文件，包括隐藏文件
- -l 显示详细信息
- -d 查看目录属性
- -h 人性化显示文件大小
- -i 显示inode，文件id号，每个文件都有

```
-rw-r--r-- 1 root root 6140
文件权限421
最前面显示文件类型（目录d，软链是l）
用户组区分开了
u所有者g所有组o其他人（任意所有人）
1代表引用计数
后面会跟root root这样类似的对应
文件大小
点“.”开头的文件，是属于系统文件，不懂别乱动点开头点文件
ls -lh 是比较常用的，一般都要有-l
```

### 建立目录：mkdir
- -p递归创建

### 切换所在目录：cd

- cd ~ 进入到当前用户的家目录
- cd - 进入上次目录
- cd .. 进入上一级目录
- cd . 进入当前目录

### 查看当前目录pwd

### 查看当前进程运行的目录：pwdx

### 删除空目录：rmdir

### 删除文件或目录：rm
- -r 删除目录
- -f 强制
- -i 提醒是否确定删

```
rm -rf /tmp/* 如果是要在某个目录下的文件，要加*，否则包括目录
```
 
### 复制命令：cp
- -r 复制目录
- -p 连带文件属性复制
- -d 若源文件为链接文件，则复制链接属性
- -a 相当于-pdr

### 剪切或改名命令：mv

### 目录
根目录下的bin和sbin，usr目录下的bin和sbin，这四个目录都是从来保存系统命令的

proc和sys目录不能直接操作，这两个目录保存的是内存的挂载点

```
/根目录
/bin命令保存目录（普通用户可以读取）
/sbin命令保存目录（超级用户可以读取）
/boot 启动目录，启动相关文件
/dev 设备文件保存目录
/etc 配置文件保存目录
/home 普通用户的家目录
/lib 系统库保存目录
/mnt 系统挂载目录
/media 挂载目录
/root 超级用户的家目录
/tmp 临时目录
/proc 直接写入内存的
/sys 
/usr 系统软件资源目录
/usr/bin 系统命令（普通用户）
/usr/sbin 系统命令（超级用户）
/var 系统相关文档内容
```

### 链接命令：ln
ln 生成链接文件，这样是硬链接，配置硬链接后引用计数会变化+1
- -s 创建软链接

```
硬链接特征：
1. 拥有相同的i节点和存储block块，可以看做是同一个文件，删掉一个，另一个还能继续打开，都是引用
2. 可通过i节点识别，比较难区分
3. 不能跨分区
4. 不能针对目录使用
5. 删除原文件，硬链接还可以用

软链接方式：
1. 类似windnows快捷方式，提示方便
2. 软链接拥有自己的i节点和存储block块，但是数据块中只包存原文件的文件名和I节点号，并没有实际数据
3. lrwxrwxrwx l软链接 软链接文件权限都为rwxrwxrwx
4. 修改任意文件，另一个都改变
5. 删除原文件，软链不能使用
6. 软链接要写绝对路径
```

### 文件搜索命令：locate
locate 文件名

在后台数据库中按文件名搜索，搜索速度更快

- /var/lib/mlocate 搜索的后台数据库，更新频率应该是一天一次
- updatedb 更新数据库，新建文件的时候执行更新
- /etc/updatedb.conf配置文件 筛选规则

/etc/updatedb.conf
```
# 开启搜索限制规则
PRUNE_BIND_MOUNTS = "yes"
# 搜索时，不搜索的文件系统
PRUNEFS =
# 搜索时，不搜索的文件类型
PRUNENAMES =
# 搜索时，不搜索的路径
PRUNEPATHS =
```

### 命令搜索命令：whereis与which
#### whereis
whereis 命令名 

搜索命令所在路径及帮助文档所在位置
- 只能查系统命令，比如ll是ls -l的别名查不出来
- -b 只查找可执行文件
- -m 只查找帮助文件

#### which
where 命令名 
- 可以查出来ll是ls -l的别名
- 可以通过配置PATH环境变量，其定义的是系统搜索命令的路径 echo $PATH


### 查看当前用户是谁：whoami
### 查看当前当前命令用处：whatis  命令


### 命令搜索命令：find
find [搜索范围] [搜索条件] find ./ -name xxx
- 避免大范围搜索，会非常耗费系统资源
- 完全匹配，可以使用通配符匹配  
```
   * 匹配任意内容
   ？ 匹配任意一个字符
   [] 匹配任意一个中括号内的字符
```
- -iname 不区分大小写
- -user 按照所有者搜索
- -nouser 查找没有所有者的文件（内核产生或者windows文件，否则可能是垃圾文件）
- -mtime +10 查找10天前修改的文件，数字是可以改变的
```
	-10 10天内修改文件 
	10 10天当前修改的文件
	+10 10天前修改的文件
	atime 文件访问时间
	ctime 改变文件属性
	mtime 改变文件内容
```
- -size 25k 查找文件是25KB，可以换成M等单位
```
    -25k 小于25KB的文件
    25k 等于25KB的文件
    +25k 大于25KB的文件
```
- -inum 262422 查找i节点时262422的文件
- find /etc -size + 20k -a -size -50k 查找/etc下，大于20KB并且小于50KB的文件
```
   -a and 逻辑与 
   -o or 逻辑或
```
- find /etc -size +20k -a -size -50k -exec ls -lh {} \; 查找/etc下，大于20KB并且小于50KB的文件，并显示详细信息
```
-exec 命令 {} \; 对搜索结果执行操作
```

### 字符串搜索命令： grep
grep [选项] 字符串 文件名
在文件当中匹配符合条件的字符串，比如 grep "xxx" "file.xxx"
- -i 忽略大小写
- -v 排除指定字符串
- 包含匹配

### 帮助命令：man
man 命令 获取指定命令的帮助

### 其他帮助命令 --help，info

### 压缩命令
常用压缩格式：.zip，.gz，.bz2
#### .zip格式压缩
- zip 压缩文件名 源文件 压缩文件
- zip -r 压缩文件名 源目录 压缩目录
```
zip -r mulu.zip mulu
```
- unzip 文件名 解压缩

#### gz格式压缩
- gzip 源文件 压缩为.gz格式的压缩文件，源文件会消失
```
gzip 1.txt
```
- gzip -c 源文件 > 压缩文件
```
压缩为.gz格式，源文件保留
例如：gzip -c 1.txt > 1.gz
```
- gzip -r 目录 将压缩目录下所有的子文件，但是不能压缩目录，都是变成一个一个的压缩文件
- gzip -d 压缩文件  #解压缩文件
- gunzip 压缩文件  #解压缩文件，解压目录-r

#### .bz2格式压缩
- bzip2 源文件 #压缩为.bz2格式，不保留源文件
- bzip2 -k 源文件 #压缩之后保留源文件
- 注意：bzip2命令不能压缩目录
- bzip -d 压缩文件 #解压缩，-k保留压缩文件
- bunzip2 压缩文件 #解压缩，-k保留压缩文件

常用压缩格式：.tar.gz，.tar.bz2

#### .tar.gz格式压缩
##### 打包命令 tar
- -c 打包
- -v 显示过程
- -f 显示打包后的文件名

```
tar -cvf mulu.tar mulu
gzip mulu.tar
```
#### 解打包 tar -xvf 打包文件名
- x 解打包

```
tar -xvf mulu.tar 
```

其实.tar.gz格式是先打包为.tar格式，再压缩为.gz格式
- tar -zcvf 压缩包名.tar.gz 源文件
  -z 压缩为.tar.gz格式
- tar -zxvf 压缩包名.tar.gz
  -x 解压缩.tar.gz格式

#### .tar.bz2格式压缩
两步
```
tar -cvf mulu.tar mulu
bzip2 mulu.tar
```
一步
- tar -jcvf 压缩包名.tar.bz2 源文件
  -j 压缩为.tar.bz2格式
- tar -jxvf 压缩包名.tar.bz2
  -x 解压缩.tar.bz2格式

```
tar -jxvf mulu.tar.bz2 -C /tmp/ # 解压到指定位置
```

#### 查看压缩包里的内容： tar -ztvf test.tar.gz

### 关机和重启命令
#### shutdown命令 
shutdown [选项] 时间
- -c 取消前一个关机时间
- -h 关机
- -r 重启

```
shutdown -r 05:30 &  # 后台运行，指定时间到重启
```

#### 其他关机命令 
```
halt
poweroff
init 0
```
#### 其他重启命令
```
reboot
init 6
```
#### 退出命令
```
logout
```

### 其他常用命令
#### 挂载命令
##### 查询与自动挂载
mount 查询系统中已经挂载的设备

mount -a 依据配置文件/etc/fstab的内容，自动挂载

mount [-t 文件系统] [-o 特殊设备] 设备文件名 挂载点
- -t 文件系统，加入文件系统类型来指定挂载的类型，可以ext3,ext4,iso9660等文件系统
- -o 特殊选项，可以指定挂载的额外选项

挂载光盘
```
mkdir /mnt/cdrom/  # 建立挂载点
mount -t iso9660 /dev/sr0 /mnt/cdrom   # 挂载光盘
```
卸载光盘
```
umount 设备文件名或挂载点
umount /mnt/cdrom
```
挂载U盘，Linux默认是不支持NTFS文件系统的
```
fdisk -l # 查看U盘设备文件名
mount -t vfat /dev/sdb1 /mnt/usb 
```
#### 用户登录查看和用户交互命令
##### w命令
w 用户名
命令输出：
- USER:登录的用户名
- TTY:登录终端 pst/0远程第一个终端
- FROM:从哪个IP地址登录
- LOGIN@:登录时间
- IDLE:用户闲置时间
- JCPU:指的是该终端连接的所有进程占用的时间，这个时间并不包括过去的后台作业时间，但却包含当前正在运行的后台作业所占用的时间
- PCPU:是指当前进程所占用的时间
- WHAT:当前正在运行的命令

##### who命令
命令输出：
- 用户名
- 登录终端
- 登录时间（登录来源IP）

##### last 命令
查询当前登录和过去登录的用户信息，last命令默认是读取/var/log/wtmp文件数据
命令输出
- 用户名
- 登录终端
- 登录IP
- 登录时间
- 退出时间（在线时间）

##### lastlog 命令
查看所有用户的最后一次登录时间，命令默认读取/var/log/lastlog文件内容
命令输出
- 用户名
- 登录终端
- 登录IP
- 最后一次登录时间

### Shell基础
#### echo命令
echo "xxx"

- -e 支持反斜线控制的字符转换

```
\a 输出警告符
\b 退格键，向左删除键
\n 换行符
\r 回车符
\t 制表符，也就是tab键
\v 垂直制表符

echo -e "bbi\bf"

bbf
```

shell脚本
```
#!/bin/bash
# 井号代表注释
```
脚本执行
```
# 赋予执行权限
chmod 755 hello.sh
./hello.sh
#通过bash调用执行脚本
bash hello.sh
```

#### alias
可以显示简写命令，可以修改，但是重启会不起作用
```
alias ls='ls --color=never
```
除非写入环境变量 
```
vi ~/.bashrc
```
删除别名
```
unalias 别名 
```

#### 命令生效顺序

第一顺位执行用绝对路径或相对路径执行的命令/bin/xxx之类的

第二顺位执行别名

第三顺位执行Bash的内部命令

第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的第一个命令

#### 常用快捷键
- ctrl + c 强制终止当前命令
- ctrl + l 清屏
- ctrl + a 光标移动到命令行首
- ctrl + e 光标移动到命令行位
- ctrl + u 从光标所在位置删除到行首
- ctrl + z 把命令放入后台
- ctrl + r 在历史命令中搜索

#### history 
- -c 清空历史命令
- -w把缓存中的历史命令写入历史命令保存文件~/.bash_history

历史命令默认会保存1000条，可以在环境变量配置文件/etc/profile中进行修改HISTSIZE

历史命令的调用
- 使用上下箭头调用以前的历史命令
- 使用"!n"重复执行第n条历史命令
- 使用"!!"重复执行上一条命令
- 使用"!字串"重复执行最后一条以该字串开头的命令

#### 输出重定向
##### 1.标准输入输出

设备|设备文件名|文件描述符|类型
-|-|-|-
键盘|/dev/stdin|0|标准输入
显示器|/dev/stdout|1|标准输出
显示器|/dev/stderr|2|标准错误输出

##### 2.输出重定向

<table style="margin-top: -20px;">
	<tr>
	    <th>类型</th>
	    <th>符号</th>
	    <th>作用</th>  
	</tr >
	<tr>
	    <td rowspan="2">标准输出重定向</td>
	    <td>命令 > 文件</td>
	    <td>以覆盖的方式，把命令的正确输出输出到指定的文件或设备当中</td>
	</tr>
	<tr>
		<td>命令 >> 文件</td>
	    <td>以追加的方式，把命令的正确输出输出到指定的文件或设备当中</td>
	</tr>
	<tr>
	    <td rowspan="2">标准错误输出重定向</td>
	    <td>错误命令2>文件</td>
	    <td>以覆盖的方式，把命令的错误输出输出到指定的文件或设备当中</td>
	</tr>
	<tr>
		<td>错误命令2>>文件</td>
	    <td>以追加的方式，把命令的错误输出输出到指定的文件或设备当中</td>
	</tr>
	<tr>
	    <td rowspan="5">正确输出和错误输出同时保存</td>
	    <td>命令 > 文件 2>&1</td>
	    <td>以覆盖的方式，把正确输出和错误输出都保存到同一个文件中</td>
	</tr>
	<tr>
	    <td>命令 >> 文件 2>&1</td>
	    <td>以追加的方式，把正确输出和错误输出都保存到同一个文件中</td>
	</tr>
	<tr>
	    <td>命令 &> 文件</td>
	    <td>以覆盖的方式，把正确输出和错误输出都保存到同一个文件中</td>
	</tr>
	<tr>
	    <td>命令 &>> 文件</td>
	    <td>以追加的方式，把正确输出和错误输出都保存到同一个文件中</td>
	</tr>
	<tr>
	    <td>命令>>文件1 2>>文件2</td>
	    <td>把正确的输出追加到文件1中，把错误的输出追加到文件2中</td>
	</tr>
</table>

2>> 2> 错误输出到test.log，需要注意没有加空格
```
errorxxx 2>> test.log

//test.log
-bash: errorxxx: command not found
```

##### 输入重定向
wc [选项] [文件名]
- -c 统计字节数
- -w 统计单词数
- -l 统计行数

命令<文件 把文件作为命令的输入 
```
wc < access.log
wc access.log

wc << ddy # 可以一直追加，除非再敲完全相同ddy才会停止，ddy可以理解为标记
```

#### 管道符
##### 1.多命令顺序执行
多命令执行符|格式|作用
-|-|-
;|命令1;命令2|多个命令顺序执行，命令之间没有任何逻辑联系
&&|命令1&&命令2|逻辑与 当命令1正确执行，则命令2才会执行 当命令2执行不正确，则命令2不会执行
&#124;&#124;|命令1&#124;&#124;命令2|逻辑或,当命令1执行不正确，则命令2才会执行 当命令1正确执行，则命令2不会执行

##### 2.管道符|
命令1|命令2 命令1的正确输出作为命令2的操作对象
```
ls -l /etc | more # 可以看到list列表一页一页显示
```
统计客户端连接
```
netstat -an | grep ESTABLISHED | wc -l
```


#### 通配符
通配符|作用
-|-
?|匹配任意一个字符
*|匹配0个或任意多个任意字符，也就是可以匹配任何字符
[]|匹配中括号中任意一个字符，例如：[abc]代表一定匹配一个字符，或者是a，或者是b，或者是c
[-]|匹配中括号中任意一个字符，-代表一个范围，例如：[a-z]代表匹配一个小写字母
[^]|逻辑非，表示匹配不是中括号内的一个字符，例如：[^0-9]代表匹配一个不是数字的字符

```
ls mysql*
```

#### Bash中其他特殊符号
符号|作用
-|-
''|单引号。在单引号中所有特殊字符，如'$'和"`"（反引号）都没有特殊含义
""|双引号。在双引号中特殊字符都没有特殊含义，但是"$"、"`"和"\"是例外，拥有"调用变量的值"、"引用命令"和"转义符"的特殊含义
``|反引号。反引号括起来的内容是系统命令，在Bash中会先执行它。和$()作用一样，不过推荐使用$()，因为反引号容易看错
$()|和反引号作用一样，用来引号系统命令
#|在shell脚本中，#开头的行代表注释
$|用于调用变量的值，如需要调用变量name的值时，需要用$name的方式得到变量的值
\|转义符，跟在\之后的特殊符号将失去特殊含义，变为普通字符，如\$将输出"$"符号，而不当做是变量引用

```
[root@VM_0_2_centos ~]# aa=123
[root@VM_0_2_centos ~]# echo $aa
123
[root@VM_0_2_centos ~]# echo aa
aa
[root@VM_0_2_centos ~]# echo '$aa'
$aa
[root@VM_0_2_centos ~]# echo "$aa"
123

aa = ls
echo "$aa"  # 打印ls

aa = `ls` # ls执行结果赋给aa
echo "$aa" # 打印ls的结果
```